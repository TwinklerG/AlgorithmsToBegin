# 算法入门



## 位运算

### 子集的异或总和再求和

([1863. 找出所有子集的异或总和再求和 - 力扣](https://leetcode.cn/problems/sum-of-all-subset-xor-totals/))

伪代码：每个子集选与不选分别为0与1，各种选法均代表一个独一的十进制数，共2^n^种。在每个循环中再遍历每个元素，判断其所在位在当前选法的二进制数对应位是否均为1，若为则选；否则不选。

```c++
int subsetXORSum(vector<int>& nums) {
    int i,j,ans = 0;
    for (int i = 0; i < 1<<nums.size(); i++){
        int sum = 0;
        for (int j = 0; j < nums.size(); j++){
            if (i & 1<<j){
                sum ^= nums[j];
            }
        }
        ans += sum;
    }
    return ans;
}
```

### 两整数之和

伪代码：两整数的二进制表示相同位均为1时产生进位，否则采用异或运算。

```c++
int getsum(int a, int b){
    return b == 0 ? a : getsum(a ^ b, (a & b) << 1);
}
```

### 插入

([面试题 05.01. Insert Into Bits LCCI - 力扣](https://leetcode.cn/problems/insert-into-bits-lcci/description/))

伪代码：先将目标段位清零，再与目标值左移指定位的结果位或。

```c++
int insertBits(int N, int M, int i, int j) {
    for (int k = i; k <= j; k++){
      N = N & ~(1<<k);
    }
    N |= (M<<i);
    return N;
}
```



## 动态规划

### 打家劫舍

([LCR 089. 打家劫舍 - 力扣](https://leetcode.cn/problems/Gu0c2T/))

伪代码：第i家获的最大值为第i-1家获得的最大值或第i-2家与偷第i家的最大值。

```c++
int rob(vector<int>& nums) {
    if (nums.size() == 1){
        return nums[0];
    }
    int dp[101] = {0};
    dp[0] = nums[0];
    dp[1] = max(nums[0],nums[1]);
    for (int i = 2; i < nums.size(); i++){
        dp[i] = max(dp[i - 1],dp[i - 2] + nums[i]);
    }
    return dp[nums.size() - 1];
}
```

### 打家劫舍II

([LCR 089. 打家劫舍 - 力扣](https://leetcode.cn/problems/Gu0c2T/))

伪代码：采用`dp[maxN][2]`的动态规划数组，第二维0表示起始点未选，第二维1表示起始点选择。

```c++
#define maxN 101
int rob(vector<int> &nums) {
  int dp[maxN][2] = {0};
  if (nums.size() == 1) {
    return nums[0];
  } else if (nums.size() == 2) {
    return max(nums[0], nums[1]);
  }
  dp[0][0] = 0;
  dp[0][1] = nums[0];
  for (int i = 1; i < nums.size(); i++) {
    for (int j = 0; j < 2; j++) {
      if (i == 1) {
        if (j == 1) {
          dp[i][j] = nums[0];
        } else {
          dp[i][j] = nums[1];
        }
      }
      if (i == nums.size() - 1 && j == 1) {
        dp[i][j] = dp[i - 1][j];
      } else {
        dp[i][j] = max(dp[i - 1][j], dp[i - 2][j] + nums[i]);
      }
    }
  }
  return max(dp[nums.size() - 1][0], dp[nums.size() - 1][1]);
}
```

### 分隔数组以得到最大值

([1043. 分隔数组以得到最大和 - 力扣](https://leetcode.cn/problems/partition-array-for-maximum-sum/description/))

伪代码：采用`dp[i]`表示当前子数组的最大值，状态转移为一个一重循环遍历查找最大值。

```c++
int maxSumAfterPartitioning(vector<int> &arr, int k) {
  int dp[500] = {0};
  for (int i = 0; i < arr.size(); i++) {
    int cut = 0;
    int maxv = arr[i];
    for (int j = i; j >= 0; j--) {
      cut++;
      if (cut > k) {
        break;
      }
      if (arr[j] > maxv) {
        maxv = arr[j];
      }
      if (j) {
        dp[i] = max(dp[i], dp[j - 1] + cut * maxv);
      } else {
        dp[i] = max(dp[i], cut * maxv);
      }
    }
  }
  return dp[arr.size() - 1];
}
```

### 单词拆分

([139. 单词拆分 - 力扣](https://leetcode.cn/problems/word-break/submissions/502015058/))

思路：状态转移时对每一个元素进行判断，有一个满足则成立。

```c++
bool wordBreak(string s, vector<string> &wordDict) {
  int dp[301] = {0};
  for (int i = 0; i < s.size(); i++) {
    for (int j = 0; j < wordDict.size(); j++) {
      int len = wordDict[j].size();
      if (i - len + 1 < 0) {
        continue;
      }
      if (i - len != -1 && !dp[i - len]) {
        continue;
      }
      int k;
      for (k = 0; k < len; k++) {
        if (wordDict[j][k] != s[i - len + 1 + k]) {
          break;
        }
      }
      if (k == len) {
        dp[i] = 1;
      }
    }
  }
  return dp[s.size() - 1];
}
```

==前缀和==：递推求和

二维前缀和

### 最长递增子序列

([300. 最长递增子序列 - 力扣](https://leetcode.cn/problems/longest-increasing-subsequence/description/))

思路：对于每个数组元素，遍历其之前的所有元素，若满足递增条件，则进入状态转移的判定。

```c++
class Solution {
#define maxl 2500
 public:
  int lengthOfLIS(vector<int> &nums) {
    int maxv = 1;
    int dp[maxl] = {0};
    dp[0] = 1;
    for (int i = 1; i < nums.size(); i++) {
      dp[i] = 1;
      for (int j = 0; j < i; j++) {
        if (nums[j] < nums[i]) {
          dp[i] = max(dp[j] + 1, dp[i]);
        }
      }
      if (maxv < dp[i]) {
        maxv = dp[i];
      }
    }
    return maxv;
  }
};
```

### 最长的斐波那契子数列

([LCR 093. 最长的斐波那契子序列的长度 - 力扣（LeetCode）](https://leetcode.cn/problems/Q91FMA/))

思路：用一个`dp[i][j]`记录第i位数字与第j位数字构成的最长的斐波那契子数列。用二分查找对应元素的下标。

==特殊技巧==：定义二分查找函数时，采用引用而非拷贝可以大大提高运行速度，防止超时。

```c++
class Solution {
    int dp[1000][1000];
    int findv(vector<int>& arr, int l, int r, int val){
        while (l <= r){
            int mid = (l + r) >> 1;
            if (arr[mid] == val){
                return mid;
            } else if (arr[mid] > val){
                r = mid - 1;
            } else {
                l = mid + 1; 
            }
        }
        return -1;
    }
public:
    int lenLongestFibSubseq(vector<int>& arr) {
        int ans = 1;
        for (int i = 0; i < arr.size(); i++){
            for (int j = 0; j < i; j++){
                int idex = findv(arr,0,j-1,arr[i] - arr[j]);
                if (idex != -1){
                    dp[i][j] = dp[j][idex] + 1;
                } else {
                    dp[i][j] = 2;
                }
                ans = max(dp[i][j],ans);
            }
        }
        return ans > 2 ? ans : 0;
    }
};
```

### 最长回文子序列

([516. 最长回文子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-palindromic-subsequence/submissions/502170648/))

思路一：将原字符串翻转的结果与原字符串求最大相同子序列长度即为结果。

思路二：动态规划原来的字符串，`dp[i][j]`表示从i到j的最长回文子序列长度。

* 思路一代码：

```c++
class Solution {
public:
    int maxsame(string s1, string s2){
        int maxl = 0;
        int dp[1000][1000] = {0};
        for (int i = 0; i < s1.size(); i++){
            for (int j = 0; j < s2.size(); j++){
                if (s1[i] == s2[j]){
                    if (i == 0 || j == 0){
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = dp[i - 1][j - 1] + 1;
                    }
                } else {
                    if (i == 0 && j == 0){
                        dp[i][j] = 0;
                    } else if (i == 0){
                        dp[i][j] = dp[i][j - 1];
                    } else if (j == 0){
                        dp[i][j] = dp[i - 1][j];
                    } else {
                        dp[i][j] = max(dp[i - 1][j],dp[i][j - 1]);
                    }
                }
                if (maxl < dp[i][j]){
                    maxl = dp[i][j];
                }
            }
        }
        return maxl;
    }
    int longestPalindromeSubseq(string s) {
        string s2 = s;
        reverse(s2.begin(),s2.end());
        return maxsame(s,s2);
    }
};
```

* 思路二代码：

==注意==：状态转移的循环顺序。

```c++
class Solution {
    int dp[1000][1000] = {0};
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        int ans = 1;
        for (int i = n - 1; i >= 0; i--){
            dp[i][i] = 1;
            for (int j = i + 1; j < n; j++){
                if (s[i] == s[j]){
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = max(dp[i + 1][j],dp[i][j - 1]);
                }
                if (dp[i][j] > ans){
                    ans = dp[i][j];
                }
            }
        }
        return ans;
    }
};
```

### 编辑距离

思路：`dp[i][j]` 代表 `word1` 中前 `i` 个字符，变换到 `word2` 中前 `j` 个字符，最短需要操作的次数。状态转移：

增：`dp[i][j] = dp[i][j - 1] + 1`

删：`dp[i][j] = dp[i - 1][j] + 1`

改：`dp[i][j] = dp[i - 1][j - 1] + 1`

==注意==：需要考虑 `word1` 或 `word2` 一个字母都没有，即全增加/删除的情况，所以预留 `dp[0][j]` 和 `dp[i][0]`。

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int dp[501][501] = {0};
        for (int i = 0; i <= word1.size(); i++){
            dp[i][0] = i;
        }
        for (int i = 0; i <= word2.size(); i++){
            dp[0][i] = i;
        }
        for (int i = 1; i <= word1.size(); i++){
            for (int j = 1; j <= word2.size(); j++){
                if (word1[i - 1] == word2[j - 1]){
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

### 买卖股票的最佳时机III

([123. 买卖股票的最佳时机 III - 力扣（LeetCode）](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/))

思路：动态规划，3个维度，分别为当前元素位置，是否持有股票，完成的交易次数。

==注意==：设定非法状态。

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int ans = 0;
        int dp[100000][2][3] = {0};
        int n = prices.size();
        memset(dp,-0x3f3f3f3f,sizeof(dp));
        for (int i = 0; i < n; i++){
            dp[i][0][0] = 0;
        }
        dp[0][1][1] = -prices[0];
        for (int i = 1; i < prices.size(); i++){
            for (int k = 1; k < 3; k++){
                dp[i][0][k] = max(dp[i - 1][0][k], dp[i - 1][1][k] + prices[i]);
                dp[i][1][k] = max(dp[i - 1][0][k - 1] - prices[i], dp[i - 1][1][k]);
            }
        }
        return max({0,dp[prices.size() - 1][0][1],dp[prices.size() - 1][0][2]});
    }
};
```

### 分割等和数组

([LCR 101. 分割等和子集 - 力扣（LeetCode）](https://leetcode.cn/problems/NUPfPr/description/))

思路：数组和为奇数，显然不成立。否则则判断是否数组可选子集和为数组和的一半。对于每个元素，有有选和不选两种情况。定义一个`dp[i]`数组，表示是否可以凑成和为i的子集。

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int dp[200100] = {0};
        int sum = 0;
        int n = nums.size();
        for (int i = 0; i < n; i++){
            sum += nums[i];
        }
        if (sum % 2){
            return false;
        }
        sum /= 2;
        dp[0] = 1;
        for (int i = 0; i < n; i++){
            for (int j = sum; j >= nums[i]; j--){
                dp[j] |= dp[j - nums[i]];
            }
            if (dp[sum]){
                return true;
            }
        }
        return false;
    }
};
```

### 矩阵中的最长递增路径

([LCR 112. 矩阵中的最长递增路径 - 力扣（LeetCode）](https://leetcode.cn/problems/fpTFWP/))

思路：==记忆化搜索==。对于每个位置，进行四个方向的试探，求出当前位置为**终点**的最长递增路径。

> dfs：深度优先搜索。

```c++
class Solution {
    int vect[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};
    int dp[201][201];
public:
    int dfs(vector<vector<int>>& matrix, int x, int y, int dp[][201], int m, int n){
        //已经搜索过
        if (dp[x][y] != -1){
            return dp[x][y];
        }
        //新的搜索
        dp[x][y] = 1;
        int tx, ty;
        for (int i = 0; i < 4; i++){
            tx = x + v[i][0];
            ty = y + v[i][1];
            if (tx < 0 || ty < 0 || tx >= m || ty >= n){
                continue;
            }
            if (matrix[tx][ty] >= matrix[x][y]){
                continue;
            }
            dp[x][y] = max(dp[x][y],dfs(matrix,tx,ty,dp,m,n) + 1);
        }
        return dp[x][y];
    }
    int longestIncreasingPath(vector<vector<int>>& matrix) {
        int ans = 1;
        memset(dp,-1,sizeof(dp));
        for (int i = 0; i < matrix.size(); i++){
            for (int j = 0; j < matrix[0].size(); j++){
                ans = max(ans,dfs(matrix,i,j,dp,matrix.size(),matrix[0].size()));
            }
        }
        return ans;
    }
};
```

## 哈希表

### 和相同的二元子数组

([930. 和相同的二元子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-subarrays-with-sum/))

思路：**前缀和**+**查分**。然后用**哈希表**存取前缀和，边遍历，边计算。

```c++
class Solution {
public:
    int numSubarraysWithSum(vector<int>& nums, int goal) {
        int sum[30001] = {0};
        int hash[60001] = {0};
        hash[0] = 1;
        sum[0] = nums[0];
        int ans = 0;
        for (int i = 0; i < nums.size(); i++){
            if (i == 0){
                sum[i] = nums[i];
            } else {
                sum[i] = sum[i - 1] + nums[i];
            }
            if (sum[i] >= goal){
                ans += hash[sum[i] - goal];
            }
            hash[sum[i]]++;
        }
        return ans;
    }
};
```

变式：数据范围变大。利用C++中STL中的`unordered_map`模拟哈希表。

([LCR 010. 和为 K 的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/QTMn0o/description/))

```c++
class Solution {
    unordered_map<int,int> hash;
public:
    int subarraySum(vector<int>& nums, int k) {
        int sum[20000] = {0};
        hash[0] = 1;
        int ans = 0;
        for (int i = 0; i < nums.size(); i++){
            if (i == 0){
                sum[i] = nums[i];
            } else {
                sum[i] = sum[i - 1] + nums[i];
            }
            ans += hash[sum[i] - k];
            hash[sum[i]]++;
        }
        return ans;
    }
};
```

### 四数相和II

([454. 四数相加 II - 力扣（LeetCode）](https://leetcode.cn/problems/4sum-ii/description/))

思路：时间复杂度控制在O(n^2^)。采用一个哈希表记录`nums1`,`nums2`中的的和的出现次数，再用一个二重循环遍历`nums3`,`nums4`求出结果。

```c++
class Solution {
    unordered_map<int,int> hash;
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        for (int i = 0; i < nums1.size(); i++){
            for (int j = 0; j < nums2.size(); j++){
                hash[-(nums1[i] + nums2[j])]++;
            }
        }
        int ans = 0;
        for (int i = 0; i < nums3.size(); i++){
            for (int j = 0; j < nums4.size(); j++){
                ans += hash[nums3[i] + nums4[j]];
            }
        }
        return ans;
    }
};
```

### 相交链表

([LCR 023. 相交链表 - 力扣（LeetCode）](https://leetcode.cn/problems/3u1WK4/description/))

思路：定义一个特殊的哈希表。`unordered_map<ListNode*,bool>`。使用`.find()`方法。时间复杂度O(m+n)。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
    unordered_map<ListNode*,bool> hash;
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        while(headA != NULL){
            hash[headA] = true;
            headA = headA->next;
        }
        while(headB != NULL){
            if (hash.find(headB) != hash.end()){
                return headB;
            }
            headB = headB->next;
        }
        return NULL;
    }
};
```

> 补充：双指针，数学方法。时间复杂度O(1)。

```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *h1 = headA, *h2 = headB;
        if (!h1 || !h2){
            return NULL;
        }
        while (h1 != h2){
            h1 = h1 == NULL ? headB : h1->next;
            h2 = h2 == NULL ? headA : h2->next;
        }
        return h1;
    }
};
```

### 滑动窗口的最大值

([239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/))

思路：线段树 && 单调队列。通过一个模拟双端队列存取数组下标，头元素为最大值的下标。每次遍历判断是否超长度和大小更新。

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int q[100010] = {0},front = 0,back = 0;
        vector<int> ret;
        for (int i = 0; i < nums.size(); i++){
            while (front != back && i - q[front] > k - 1){
                front++;
            }
            while (front != back && nums[i] >= nums[q[back - 1]]){
                back--;
            }
            q[back++] = i;
            if (i - k + 1 >= 0){
                ret.push_back(nums[q[front]]);
            }
        }   
        return ret;
    }
};
```

> ret：*RET*是子程序的返回指令。

## 贪心

### 分割平衡字符串

([1221. 分割平衡字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/split-a-string-in-balanced-strings/description/))

思路：每次满足平衡计数器就加一，最后计数器的结果即为所求的值。

```c++
class Solution {
public:
    int balancedStringSplit(string s) {
        int cut = 0;
        int ans = 0;
        for (int i = 0; i < s.size(); i++){
            cut += s[i] == 'L' ? 1 : -1;
            if (cut == 0){
                ans++;
            }
        }
        return ans;
    }
};
```

## 滑动窗口

==注意==：多采用线段树+单调队列的思想。
